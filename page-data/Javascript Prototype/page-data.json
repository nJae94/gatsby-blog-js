{"componentChunkName":"component---src-templates-blog-post-js","path":"/Javascript Prototype/","result":{"data":{"site":{"siteMetadata":{"title":"nJae94.io","author":{"name":"nJae94"},"siteUrl":"https://nJae94.github.io"}},"markdownRemark":{"id":"87cdc5da-7781-536f-abab-b3c440b69a1f","excerpt":"프론트 엔드 개발자로 프레임워크는 공부하면서 자바스크립트 그 자체에는 그다지 깊게 파고 들어가지 않아 본 것 같아 시작한 자바스크립트 개인 공부며 그 정리 글이 될 것 같다. ProtoType 자바스크립트 객체는 [Prototype]이라는 내부 프로퍼티가 존재하며 거의 모든 객체가 생성 시점에 값이 할당된다. 이는 또 다른 객체를 참조하는 레퍼런스로 활용된다.\n객체 프로퍼티를 참조할 경우 [Get…","html":"<p>프론트 엔드 개발자로 프레임워크는 공부하면서 자바스크립트 그 자체에는 그다지 깊게 파고 들어가지 않아 본 것 같아 시작한 자바스크립트 개인 공부며 그 정리 글이 될 것 같다.</p>\n<h2 id=\"prototype\" style=\"position:relative;\"><a href=\"#prototype\" aria-label=\"prototype permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ProtoType</h2>\n<p>자바스크립트 객체는 [[Prototype]]이라는 내부 프로퍼티가 존재하며 거의 모든 객체가 생성 시점에 값이 할당된다. 이는 또 다른 객체를 참조하는 레퍼런스로 활용된다.\n객체 프로퍼티를 참조할 경우 [[Get]]이 호출 객체 내부에 프로퍼티를 탐색하고 객체 내부에서 해당 프로퍼티를 찾지 못하면 [[ProtoType]] 링크를 따라가 탐색을 계속하며 최상위 프로토타입에서도 찾지 못한다면 undefined를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   const buzz = {\n    flying:true\n    }\n\n    const woody = Object.create(buzz);\n\n    woody.flying; ==&gt; true</code></pre></div>\n<p>위의 코드처럼 woody는 buzz와 링크되어 woody 내부에 flying이라는 프로퍼티가 직접적으로 없지만 연결된 buzz를 통해 해당 프로퍼티를 찾아 반환할 수 있다.\n이러한 현상을 프로토타입 체인이라고 부르며 프로퍼티 체인은 메모리 관리의 관점에서 장점이 있다.</p>\n<h2 id=\"프로토타입-체인\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\" aria-label=\"프로토타입 체인 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로토타입 체인</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">funtion Num(number)\n{\n  this.num = num;\n  this.getValue = function() {\n    console.log(num);\n  }\n}\n\nconst n1 = new Num(1);\nconst n2 = new Num(2);</code></pre></div>\n<p>Num 함수는 number를 받고 getValue라는 함수를 통해 출력한다. new 키워드를 사용해 객체를 만들어 낼 때 공통적으로 사용되는 getValue라는 메소드 역시도 객체가 생성될 때마다 메모리에 생성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> funtion Num(number)\n{\n  this.num = num;\n}\n\nNum.prototype.getValue = function() {\n  console.log(num);\n}</code></pre></div>\n<p>공통 메소드 getValue를 prototype에 정의하고 객체를 생성하자 각 객체 안에서는 getValue 프로퍼티가 존재하지 않고 프로토타입 체인을 통해 각 객체들이 같은 prototype의 메소드를 참조하게 되어 메모리에 효율적이다.</p>","tableOfContents":"<ul>\n<li><a href=\"/Javascript%20Prototype/#prototype\">ProtoType</a></li>\n<li><a href=\"/Javascript%20Prototype/#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\">프로토타입 체인</a></li>\n</ul>","frontmatter":{"title":"자바스크립트 Prototype 정리","date":"March 24, 2021"}}},"pageContext":{"slug":"/Javascript Prototype/","previous":{"fields":{"slug":"/Nest.js 초기 셋팅/"},"frontmatter":{"title":"Nextjs란 무엇인가?","category":"front","draft":false}},"next":null}},"staticQueryHashes":[]}